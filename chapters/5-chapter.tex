\chapter{Conclusão}
Nosso objetivo com o trabalho era buscar formas de consultar por polígonos para o desenvolvimento de jogos e aplicações gráficas de tempo real. O objetivo era demonstrar que não só haveria um ganho de performance para determinados cenários quanto demonstrar que existem aplicações que sem otimizações como as que foram apresentadas simplesmente os problemas não poderiam ser executadas em tempo hábil.

Com a implementação de árvores $KD$ constatamos qual seria o pior caso para aceitar entre as consultas de janela em árvore. Sendo ambas, árvore $KD$ e árvore de alcance flexíveis e úteis para consulta de pontos em $N$-dimensões com uma janela. A partir do momento que estudamos árvores de alcance, sempre utilizávamos esta estrutura quando precisávamos consultar por pontos em janelas por ser mais otimizada para este objetivo fim, sendo mais performática até no pior caso de sua consulta. Com o experimento descrito na seção \ref{cap:application-points} da aplicação de pontos em um plano validamos a ideia inicial do texto. Visto que a consulta cresce de forma marginal com o crescimento dos pontos que iremos consultar, e portanto, a estrutura atinge os objetivos esperados. Poderíamos, portanto, realizar a construção de cenas arbitrariamente grandes para jogos 2D e 3D com custo marginal de tempo para aplicação. A árvore de intervalos se mostrou um excelente caso base para a árvore de segmentos. Conseguimos encontrar aplicações que seria perfeitamente aplicável para algum projeto gráfico de tempo real. Como por exemplo, poderíamos consultar em uma cena 2D apenas objetos cujas dimensões espaciais intersectem com a janela, ou seja, onde a geometria do objeto não seja de interesse apenas se está ou não presente na janela. Em jogos 2D os objetos da cena são usualmente imagens retangulares e portanto seria um excelente caso de uso. A aplicação de árvore de segmentos \ref{cap:application-segment} nós demonstramos que tal classe de aplicação só é reproduzível com alguma estrutura para consulta como a estudada neste trabalho. 

Demonstramos que para objetos que sua geometria é importante e/ou, a consulta necessita saber se segmentos de alguma figura geométrica está presente na janela, uma consulta linear em grandes resoluções inviabilizaria uma aplicação de tempo real. Com nossa estrutura de dados apresentamos uma solução possível para esta classe de problemas e demonstramos que ela executa as consultas dentro da janela limite da aplicação. Percebemos que quando a aplicação trabalhava com objetos geométricos mais complexos e em dimensões maiores (já para $2D$), as estruturas de dados eram compostas por outras estruturas auxiliares. Notamos que são estruturas que não estão limitadas a alguma dimensão específica e portanto são facilmente portáveis para dimensões maiores, e para este trabalho, são adequadas para o uso em jogos tridimensionais. As estruturas estudadas portanto permitem aceleração do pipeline gráfico por encurtarem o número de operações necessárias na aplicação e por diminuir o número de vértices enviados à placa de video para serem computados e recortados. Além disso, permite aplicações que sem estas estruturas seriam inviáveis. Com isso, concluímos que as estruturas de dados estudadas são eficientes na recuperação de objetos geométricos e poderiam ser aplicadas no desenvolvimento de jogos, e para otimizar e extrair o máximo de desempenho do sistema gráfico que esteja sendo produzido.